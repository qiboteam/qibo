"""Various utilities for tests."""
import pathlib
import numpy as np


def random_numpy_complex(shape, dtype=np.complex128):
  return (np.random.random(shape) + 1j * np.random.random(shape)).astype(dtype)


def random_tensorflow_complex(shape, dtype="float64"):
    import tensorflow as tf
    if isinstance(dtype, str):
        dtype = getattr(tf, dtype)
    _re = tf.random.uniform(shape, dtype=dtype)
    _im = tf.random.uniform(shape, dtype=dtype)
    return tf.complex(_re, _im)


def random_numpy_state(nqubits, dtype=np.complex128):
    """Generates a random normalized state vector as numpy array.

    Args:
        nqubits (int): Number of qubits in the state.
        dtype: Numpy type of the state array.

    Returns:
        Numpy array for state vector of shape (2 ** nqubits,).
    """
    x = random_numpy_complex(2 ** nqubits, dtype)
    return (x / np.sqrt((np.abs(x) ** 2).sum())).astype(dtype)


def random_numpy_hermitian(nqubits, dtype=np.complex128):
    """Generates a random Hermitian matrix as a numpy array.

    Args:
        nqubits (int): Number of qubits in matrix.
        dtype: Numpy type of the state array.

    Returns:
        Numpy array for the Hermitian matrix of shape
        (2 ** nqubits, 2 ** nqubits).
    """
    shape = 2 * (2 ** nqubits,)
    m = random_numpy_complex(shape, dtype)
    return (m + m.T.conj()) / 2.0


def random_density_matrix(nqubits: int, dtype=np.complex128) -> np.ndarray:
    """Generates a random density matrix.

    Note that the density matrix generated by this method is not necessarily
    positive. This is okay for most tests but may not work for some cases such
    as the entanglement entropy calculation.

    Args:
        nqubits (int): Number of qubits in the density matrix.

    Returns:
        Density matrix as a numpy array of shape (2 ** nqubits, 2 ** nqubits).
    """
    rho = random_numpy_hermitian(nqubits, dtype=dtype)
    # Normalize
    ids = np.arange(2 ** nqubits)
    rho[ids, ids] = rho[ids, ids] / np.trace(rho)
    return rho.astype(dtype)
