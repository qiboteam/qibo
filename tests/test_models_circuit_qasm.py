"""Tests creating abstract Qibo circuits from OpenQASM code."""

import numpy as np
import pytest
from openqasm3 import parser

from qibo import Circuit, __version__, gates


def assert_strings_equal(a, b):
    """Asserts that two strings are identical character by character."""
    assert len(a) == len(b)
    for x, y in zip(a, b):
        assert x == y


def test_empty():
    circuit = Circuit(2)
    target = f"""// Generated by QIBO {__version__}
OPENQASM 2.0;
include "qelib1.inc";
qreg q[2];"""
    assert_strings_equal(circuit.to_qasm(), target)


def test_simple():
    circuit = Circuit(2)
    circuit.add(gates.H(0))
    circuit.add(gates.H(1))
    target = f"""// Generated by QIBO {__version__}
OPENQASM 2.0;
include "qelib1.inc";
qreg q[2];
h q[0];
h q[1];"""
    assert_strings_equal(circuit.to_qasm(), target)


@pytest.mark.parametrize("extended_compatibility", [True, False])
def test_singlequbit_gates(extended_compatibility):
    circuit = Circuit(2)
    circuit.add(gates.H(0))
    circuit.add(gates.X(1))
    circuit.add(gates.Y(0))
    circuit.add(gates.Z(1))
    circuit.add(gates.S(0))
    circuit.add(gates.GPI2(1, phi=1.57))
    circuit.add(gates.SDG(1))
    circuit.add(gates.T(0))
    circuit.add(gates.TDG(1))
    circuit.add(gates.I(0))
    circuit.add(gates.GPI(0, phi=3.14))
    target = f"""// Generated by QIBO {__version__}
OPENQASM 2.0;
include "qelib1.inc";
qreg q[2];"""

    if extended_compatibility:
        target += """
gate gpi2(phi) q {u3(pi/2, phi - pi/2, pi/2 - phi) q;}
gate gpi(phi) q {u3(pi, phi - pi/2, pi/2 - phi) q;}"""

    target += """
h q[0];
x q[1];
y q[0];
z q[1];
s q[0];
gpi2(1.57) q[1];
sdg q[1];
t q[0];
tdg q[1];
id q[0];
gpi(3.14) q[0];"""
    assert_strings_equal(
        circuit.to_qasm(extended_compatibility=extended_compatibility), target
    )


def test_controlled_by_error():
    """Check that using `to_qasm` with controlled by gates raises error."""
    circuit = Circuit(3)
    circuit.add(gates.H(0))
    circuit.add(gates.Y(1).controlled_by(0, 2))
    with pytest.raises(ValueError):
        circuit.to_qasm()


def test_multiqubit_gates():
    circuit = Circuit(2)
    circuit.add(gates.H(0))
    circuit.add(gates.CNOT(0, 1))
    circuit.add(gates.X(1))
    circuit.add(gates.SWAP(0, 1))
    circuit.add(gates.X(0).controlled_by(1))
    # `controlled_by` here falls back to CNOT and should work
    target = f"""// Generated by QIBO {__version__}
OPENQASM 2.0;
include "qelib1.inc";
qreg q[2];
h q[0];
cx q[0],q[1];
x q[1];
swap q[0],q[1];
cx q[1],q[0];"""
    assert_strings_equal(circuit.to_qasm(), target)


def test_toffoli():
    circuit = Circuit(3)
    circuit.add(gates.Y(0))
    circuit.add(gates.TOFFOLI(0, 1, 2))
    circuit.add(gates.X(1))
    circuit.add(gates.TOFFOLI(0, 2, 1))
    circuit.add(gates.Z(2))
    circuit.add(gates.TOFFOLI(1, 2, 0))
    target = f"""// Generated by QIBO {__version__}
OPENQASM 2.0;
include "qelib1.inc";
qreg q[3];
y q[0];
ccx q[0],q[1],q[2];
x q[1];
ccx q[0],q[2],q[1];
z q[2];
ccx q[1],q[2],q[0];"""
    assert_strings_equal(circuit.to_qasm(), target)


def test_parametrized_gate():
    circuit = Circuit(2)
    circuit.add(gates.Y(0))
    circuit.add(gates.RY(1, 0.1234))
    target = f"""// Generated by QIBO {__version__}
OPENQASM 2.0;
include "qelib1.inc";
qreg q[2];
y q[0];
ry(0.1234) q[1];"""
    assert_strings_equal(circuit.to_qasm(), target)


def test_cu1():
    circuit = Circuit(2)
    circuit.add(gates.RX(0, 0.1234))
    circuit.add(gates.RZ(1, 0.4321))
    circuit.add(gates.CU1(0, 1, 0.567))
    target = f"""// Generated by QIBO {__version__}
OPENQASM 2.0;
include "qelib1.inc";
qreg q[2];
rx(0.1234) q[0];
rz(0.4321) q[1];
cu1(0.567) q[0],q[1];"""
    assert_strings_equal(circuit.to_qasm(), target)


def test_ugates():
    circuit = Circuit(3)
    circuit.add(gates.RX(0, 0.1))
    circuit.add(gates.RZ(1, 0.4))
    circuit.add(gates.U2(2, 0.5, 0.6))
    circuit.add(gates.CU1(0, 1, 0.7))
    circuit.add(gates.CU3(2, 1, 0.2, 0.3, 0.4))
    target = f"""// Generated by QIBO {__version__}
OPENQASM 2.0;
include "qelib1.inc";
qreg q[3];
rx(0.1) q[0];
rz(0.4) q[1];
u2(0.5, 0.6) q[2];
cu1(0.7) q[0],q[1];
cu3(0.2, 0.3, 0.4) q[2],q[1];"""
    assert_strings_equal(circuit.to_qasm(), target)

    circuit = Circuit(2)
    circuit.add(gates.CU2(0, 1, 0.1, 0.2))
    with pytest.raises(NotImplementedError):
        target = circuit.to_qasm()


def test_crotations():
    circuit = Circuit(3)
    circuit.add(gates.RX(0, 0.1))
    circuit.add(gates.RZ(1, 0.4))
    circuit.add(gates.CRX(0, 2, 0.5))
    circuit.add(gates.RY(1, 0.3).controlled_by(2))
    target = f"""// Generated by QIBO {__version__}
OPENQASM 2.0;
include "qelib1.inc";
qreg q[3];
rx(0.1) q[0];
rz(0.4) q[1];
crx(0.5) q[0],q[2];
cry(0.3) q[2],q[1];"""
    assert_strings_equal(circuit.to_qasm(), target)

    circuit = Circuit(2)
    circuit.add(gates.CU2(0, 1, 0.1, 0.2))
    with pytest.raises(NotImplementedError):
        target = circuit.to_qasm()


@pytest.mark.parametrize("qasm_type", [2, 3])
def test_u3_gate(qasm_type):
    target = Circuit(1)
    target.add(gates.U3(0, 1, 2, 3))
    target = target.to_qasm()

    # hardcoding the example to not create a `qiskit` dependency
    string = (
        ('OPENQASM 2.0;\ninclude "qelib1.inc";\nqreg q[1];\nu(1.0,2.0,3.0) q[0];')
        if qasm_type == 2
        else 'OPENQASM 3.0;\ninclude "stdgates.inc";\nqubit[1] q;\nU(1.0, 2.0, 3.0) q[0];\n'
    )
    string = Circuit.from_qasm(string)
    string = string.to_qasm()

    assert_strings_equal(string, target)


@pytest.mark.parametrize("measurements", [[gates.M(0, 1)]])
def test_measurements(measurements):
    circuit = Circuit(2)
    circuit.add(gates.X(0))
    circuit.add(gates.Y(1))
    for m in measurements:
        circuit.add(m)
    target = f"""// Generated by QIBO {__version__}
OPENQASM 2.0;
include "qelib1.inc";
qreg q[2];
creg register0[2];
x q[0];
y q[1];
measure q[0] -> register0[0];
measure q[1] -> register0[1];"""
    assert_strings_equal(circuit.to_qasm(), target)


def test_multiple_measurements():
    circuit = Circuit(5)
    circuit.add(gates.M(0, 2, 4, register_name="a"))
    circuit.add(gates.M(1, 3, register_name="b"))
    target = f"""// Generated by QIBO {__version__}
OPENQASM 2.0;
include "qelib1.inc";
qreg q[5];
creg a[3];
creg b[2];
measure q[0] -> a[0];
measure q[2] -> a[1];
measure q[4] -> a[2];
measure q[1] -> b[0];
measure q[3] -> b[1];"""
    assert_strings_equal(circuit.to_qasm(), target)


def test_capital_in_register_name_error():
    """Check that using capital letter in register name raises error."""
    circuit = Circuit(2)
    circuit.add(gates.M(0, 1, register_name="Abc"))
    with pytest.raises(NameError):
        circuit.to_qasm()


def test_from_qasm_multiqubit_gates():
    target = f"""// Generated by QIBO {__version__}
OPENQASM 2.0;
include "qelib1.inc";
qreg q[3];
cx q[0],q[2];
x q[1];
swap q[0],q[1];
cx q[1],q[0];
ccx q[1],q[2],q[0];"""
    circuit = Circuit.from_qasm(target)
    assert circuit.nqubits == 3
    assert circuit.depth == 4
    assert circuit.ngates == 5
    assert isinstance(circuit.queue[0], gates.CNOT)
    assert circuit.queue[0].qubits == (0, 2)
    assert isinstance(circuit.queue[1], gates.X)
    assert circuit.queue[1].qubits == (1,)
    assert isinstance(circuit.queue[2], gates.SWAP)
    assert circuit.queue[2].qubits == (0, 1)
    assert isinstance(circuit.queue[3], gates.CNOT)
    assert circuit.queue[3].qubits == (1, 0)
    assert isinstance(circuit.queue[4], gates.TOFFOLI)
    assert circuit.queue[4].qubits == (1, 2, 0)


def test_from_qasm_singlequbit_gates():
    target = f"""// Generated by QIBO {__version__}
OPENQASM 2.0;
include "qelib1.inc";
qreg q[2];
h q[0];
x q[1];
y q[0];
z q[1];
s q[0];
sdg q[1];
t q[0];
tdg q[1];
id q[0];"""
    circuit = Circuit.from_qasm(target)
    assert circuit.nqubits == 2
    assert circuit.depth == 5
    assert circuit.ngates == 9
    assert isinstance(circuit.queue[0], gates.H)
    assert circuit.queue[0].qubits == (0,)
    assert isinstance(circuit.queue[1], gates.X)
    assert circuit.queue[1].qubits == (1,)
    assert isinstance(circuit.queue[2], gates.Y)
    assert circuit.queue[2].qubits == (0,)
    assert isinstance(circuit.queue[3], gates.Z)
    assert circuit.queue[3].qubits == (1,)
    assert isinstance(circuit.queue[4], gates.S)
    assert circuit.queue[4].qubits == (0,)
    assert isinstance(circuit.queue[5], gates.SDG)
    assert circuit.queue[5].qubits == (1,)
    assert isinstance(circuit.queue[6], gates.T)
    assert circuit.queue[6].qubits == (0,)
    assert isinstance(circuit.queue[7], gates.TDG)
    assert circuit.queue[7].qubits == (1,)
    assert isinstance(circuit.queue[8], gates.I)
    assert circuit.queue[8].qubits == (0,)


def test_from_qasm_ugates():
    target = """OPENQASM 2.0;
qreg q[2];
u1(0.1) q[0];
u2(0.2,0.6) q[1];
cu3(0.3,0.4,0.5) q[0],q[1];
p(0.1) q[0];"""
    circuit = Circuit.from_qasm(target)
    assert circuit.depth == 3
    assert isinstance(circuit.queue[0], gates.U1)
    assert isinstance(circuit.queue[1], gates.U2)
    assert isinstance(circuit.queue[2], gates.CU3)
    assert isinstance(circuit.queue[3], gates.U1)
    assert circuit.queue[0].parameters == (0.1,)
    assert circuit.queue[1].parameters == (0.2, 0.6)
    assert circuit.queue[2].parameters == (0.3, 0.4, 0.5)
    assert circuit.queue[3].parameters == (0.1,)


def test_from_qasm_crotations():
    target = """OPENQASM 2.0;
qreg q[2];
crx(0.1) q[0],q[1];
crz(0.3) q[1],q[0];
cry(0.2) q[0],q[1];"""
    circuit = Circuit.from_qasm(target)
    assert circuit.depth == 3
    assert isinstance(circuit.queue[0], gates.CRX)
    assert isinstance(circuit.queue[1], gates.CRZ)
    assert isinstance(circuit.queue[2], gates.CRY)
    assert circuit.queue[0].parameters == (0.1,)
    assert circuit.queue[1].parameters == (0.3,)
    assert circuit.queue[2].parameters == (0.2,)


def test_from_qasm_parametrized_gates():
    target = """OPENQASM 2.0;
qreg q[2];
rx(0.1234) q[0];
rz(0.4321) q[1];
cu1(0.567) q[0],q[1];"""
    circuit = Circuit.from_qasm(target)
    assert circuit.depth == 2
    assert isinstance(circuit.queue[0], gates.RX)
    assert isinstance(circuit.queue[1], gates.RZ)
    assert isinstance(circuit.queue[2], gates.CU1)
    assert circuit.queue[0].parameters == (0.1234,)
    assert circuit.queue[1].parameters == (0.4321,)
    assert circuit.queue[2].parameters == (0.567,)


def test_from_qasm_pi_half():
    target = """OPENQASM 2.0;
include "qelib1.inc";
qreg q[1];
rx(pi/2) q[0];"""
    circuit = Circuit.from_qasm(target)
    assert circuit.depth == 1
    assert circuit.queue[0].parameters == (np.pi / 2,)


def test_from_qasm_invalid_script():

    # Qubit index out of range
    target = """OPENQASM 2.0;
qreg q[2];
x q[2];
"""
    with pytest.raises(IndexError):
        circuit = Circuit.from_qasm(target)

    # Invalid qubit index
    target = """OPENQASM 2.0;
qreg q[a];
"""
    with pytest.raises(AttributeError):
        circuit = Circuit.from_qasm(target)

    # Undefined qubit
    target = """OPENQASM 2.0;
qreg q[2];
x a[0];
"""
    with pytest.raises(KeyError):
        circuit = Circuit.from_qasm(target)
    # Invalid command `test`
    target = """OPENQASM 2.0;
qreg q[2];
test q[0];
"""
    with pytest.raises(ValueError):
        circuit = Circuit.from_qasm(target)


def test_from_qasm_measurements():
    target = """OPENQASM 2.0;
include "qelib1.inc";
qreg q[5];
creg a[3];
creg b[2];
measure q[0] -> a[0];
x q[3];
measure q[1] -> b[0];
measure q[2] -> a[1];
measure q[4] -> a[2];
measure q[3] -> b[1];"""
    circuit = Circuit.from_qasm(target)
    assert circuit.depth == 2
    assert isinstance(circuit.queue[1], gates.X)
    assert circuit.measurement_tuples == {"a": (0, 2, 4), "b": (1, 3)}


@pytest.mark.parametrize("creg_size", [2, 3, 4])
def test_from_qasm_vectorized_measurements(creg_size):
    target = f"""OPENQASM 2.0;
include "qelib1.inc";
qreg q[3];
creg a[{creg_size}];
x q[1];
measure q -> a;
"""
    if creg_size != 3:
        with pytest.raises(RuntimeError):
            circuit = Circuit.from_qasm(target)
    else:
        circuit = Circuit.from_qasm(target)
        assert circuit.depth == 2
        assert isinstance(circuit.queue[0], gates.X)
        assert circuit.measurement_tuples == {
            "a": (0, 1, 2),
        }


def test_from_qasm_measurements_order():
    target = """OPENQASM 2.0;
include "qelib1.inc";
qreg q[5];
creg a[3];
creg b[2];
measure q[2] -> b[1];
measure q[3] -> a[1];
measure q[4] -> a[0];
measure q[1] -> a[2];
measure q[0] -> b[0];
"""
    circuit = Circuit.from_qasm(target)
    assert circuit.measurement_tuples == {"a": (4, 3, 1), "b": (0, 2)}


def test_from_qasm_invalid_measurements():
    # Undefined qubit
    target = """OPENQASM 2.0;
qreg q[2];
creg a[2];
measure q[2] -> a[0];"""
    with pytest.raises(IndexError):
        circuit = Circuit.from_qasm(target)

    # Undefined register
    target = """OPENQASM 2.0;
qreg q[2];
creg a[2];
measure q[0] -> b[0];"""
    with pytest.raises(ValueError):
        circuit = Circuit.from_qasm(target)

    # Register index out of range
    target = """OPENQASM 2.0;
qreg q[2];
creg a[2];
measure q[0] -> a[2];"""
    with pytest.raises(IndexError):
        circuit = Circuit.from_qasm(target)

    # Invalid measurement command
    target = """OPENQASM 2.0;
qreg q[2];
creg a[2];
measure q[0] -> a[1] -> a[0];"""
    with pytest.raises(parser.QASM3ParsingError):
        circuit = Circuit.from_qasm(target)


def test_from_qasm_invalid_parametrized_gates():
    # Parametrize non-parametrized gate
    target = """OPENQASM 2.0;
qreg q[2];
x(0.1234) q[0];
"""
    with pytest.raises(ValueError):
        circuit = Circuit.from_qasm(target)

    # Failure to give theta value for parametrized gate
    target = """OPENQASM 2.0;
qreg q[2];
rx q[0];
"""
    with pytest.raises(ValueError):
        circuit = Circuit.from_qasm(target)

    # Invalid parameter value
    target = """OPENQASM 2.0;
qreg q[2];
rx(0.123a) q[0];
"""
    with pytest.raises(parser.QASM3ParsingError):
        circuit = Circuit.from_qasm(target)

    # Invalid parenthesis use
    target = """OPENQASM 2.0;
qreg q[2];
rx(0.123)(0.25)(0) q[0];
"""
    with pytest.raises(parser.QASM3ParsingError):
        circuit = Circuit.from_qasm(target)

    target = """OPENQASM 2.0;
include "qelib1.inc";
qreg q[3];
gate bob(theta,alpha) q0,q1 { h q1; cx q0,q1; rz(theta) q1; rx(alpha) q0; h q1; }
"""

    with pytest.raises(ValueError):
        circuit = Circuit.from_qasm(f"{target}bob(0.1, 0.2, 0.3) q[1],q[0];")

    with pytest.raises(ValueError):
        circuit = Circuit.from_qasm(f"{target}bob(0.1, 0.2) q[1],q[0],q[2];")


def test_from_qasm_gate_command(backend):
    target = """OPENQASM 2.0;
include "qelib1.inc";
gate bob(theta,alpha) q0,q1 { h q1; cx q0,q1; rz(theta) q1; rx(alpha) q0; h q1; }
gate alice q0,q1 { bob(pi/4,pi) q0,q1; x q0; bob(-pi/4,pi/2) q0,q1; }
qreg q[3];
bob(-pi/2,pi) q[0],q[2];
alice q[1],q[0];"""
    circuit = Circuit.from_qasm(target)

    def bob(theta, alpha, q0, q1):
        gate = gates.FusedGate(q0, q1)
        gate.append(gates.H(q1))
        gate.append(gates.CNOT(q0, q1))
        gate.append(gates.RZ(q1, theta=theta))
        gate.append(gates.RX(q0, theta=alpha))
        gate.append(gates.H(q1))
        return gate

    def alice(q0, q1):
        gate = gates.FusedGate(q0, q1)
        gate.append(bob(np.pi / 4, np.pi, q0, q1))
        gate.append(gates.X(q0))
        gate.append(bob(-np.pi / 4, np.pi / 2, q0, q1))
        return gate

    backend.assert_allclose(
        circuit.queue[0].matrix(backend), bob(-np.pi / 2, np.pi, 0, 2).matrix(backend)
    )
    backend.assert_allclose(
        circuit.queue[1].matrix(backend), alice(1, 0).matrix(backend)
    )


def test_from_qasm_unsupported_statement():
    target = """include "stdgates.inc";
def logical_meas(qubit[3] d) -> bit {
    bit[3] c;
    bit r;
    measure d -> c;
    r = vote(c);
    return r;
}
"""
    with pytest.raises(RuntimeError):
        circuit = Circuit.from_qasm(target)
